/*
 * Bangumi API
 *
 * 你可以在 <https://next.bgm.tv/demo/access-token> 生成一个 Access Token  ## [关于 User Agent](https://github.com/bangumi/api/blob/master/docs-raw/user%20agent.md)  如果你在使用中遇到了问题，请优先使用 GitHub issue 提交问题。在 bangumi 小组发帖可能无法得到及时反馈。
 *
 * The version of the OpenAPI document: 2025-07-1
 *
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};

/// struct for typed errors of method [`add_subject_to_index_by_index_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddSubjectToIndexByIndexIdError {
    Status400(models::ErrorDetail),
    Status401(models::ErrorDetail),
    Status404(models::ErrorDetail),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`collect_character_by_character_id_and_user_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CollectCharacterByCharacterIdAndUserIdError {
    Status400(models::ErrorDetail),
    Status401(models::ErrorDetail),
    Status404(models::ErrorDetail),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`collect_index_by_index_id_and_user_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CollectIndexByIndexIdAndUserIdError {
    Status401(models::ErrorDetail),
    Status404(models::ErrorDetail),
    Status500(models::ErrorDetail),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`collect_person_by_person_id_and_user_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CollectPersonByPersonIdAndUserIdError {
    Status400(models::ErrorDetail),
    Status401(models::ErrorDetail),
    Status404(models::ErrorDetail),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delelte_subject_from_index_by_index_id_and_subject_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DelelteSubjectFromIndexByIndexIdAndSubjectIdError {
    Status401(models::ErrorDetail),
    Status404(models::ErrorDetail),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`edit_index_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EditIndexByIdError {
    Status400(models::ErrorDetail),
    Status401(models::ErrorDetail),
    Status404(models::ErrorDetail),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`edit_index_subjects_by_index_id_and_subject_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EditIndexSubjectsByIndexIdAndSubjectIdError {
    Status400(models::ErrorDetail),
    Status401(models::ErrorDetail),
    Status404(models::ErrorDetail),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_calendar`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetCalendarError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_character_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetCharacterByIdError {
    Status400(models::ErrorDetail),
    Status404(models::ErrorDetail),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_character_image_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetCharacterImageByIdError {
    Status400(models::ErrorDetail),
    Status404(models::ErrorDetail),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_character_revision_by_revision_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetCharacterRevisionByRevisionIdError {
    Status400(models::ErrorDetail),
    Status404(models::ErrorDetail),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_character_revisions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetCharacterRevisionsError {
    Status400(models::ErrorDetail),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_episode_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetEpisodeByIdError {
    Status400(models::ErrorDetail),
    Status404(models::ErrorDetail),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_episode_revision_by_revision_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetEpisodeRevisionByRevisionIdError {
    Status400(models::ErrorDetail),
    Status404(models::ErrorDetail),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_episode_revisions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetEpisodeRevisionsError {
    Status400(models::ErrorDetail),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_episodes`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetEpisodesError {
    Status400(models::ErrorDetail),
    Status404(models::ErrorDetail),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_index_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetIndexByIdError {
    Status404(models::ErrorDetail),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_index_subjects_by_index_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetIndexSubjectsByIndexIdError {
    Status400(models::ErrorDetail),
    Status404(models::ErrorDetail),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_myself`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMyselfError {
    Status401(models::ErrorDetail),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_person_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPersonByIdError {
    Status400(models::ErrorDetail),
    Status404(models::ErrorDetail),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_person_image_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPersonImageByIdError {
    Status400(models::ErrorDetail),
    Status404(models::ErrorDetail),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_person_revision_by_revision_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPersonRevisionByRevisionIdError {
    Status400(models::ErrorDetail),
    Status404(models::ErrorDetail),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_person_revisions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPersonRevisionsError {
    Status400(models::ErrorDetail),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_related_characters_by_person_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRelatedCharactersByPersonIdError {
    Status400(models::ErrorDetail),
    Status404(models::ErrorDetail),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_related_characters_by_subject_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRelatedCharactersBySubjectIdError {
    Status400(models::ErrorDetail),
    Status404(models::ErrorDetail),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_related_persons_by_character_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRelatedPersonsByCharacterIdError {
    Status400(models::ErrorDetail),
    Status404(models::ErrorDetail),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_related_persons_by_subject_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRelatedPersonsBySubjectIdError {
    Status400(models::ErrorDetail),
    Status404(models::ErrorDetail),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_related_subjects_by_character_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRelatedSubjectsByCharacterIdError {
    Status400(models::ErrorDetail),
    Status404(models::ErrorDetail),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_related_subjects_by_person_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRelatedSubjectsByPersonIdError {
    Status400(models::ErrorDetail),
    Status404(models::ErrorDetail),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_related_subjects_by_subject_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRelatedSubjectsBySubjectIdError {
    Status400(models::ErrorDetail),
    Status404(models::ErrorDetail),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_subject_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSubjectByIdError {
    Status400(models::ErrorDetail),
    Status404(models::ErrorDetail),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_subject_image_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSubjectImageByIdError {
    Status400(models::ErrorDetail),
    Status404(models::ErrorDetail),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_subject_revision_by_revision_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSubjectRevisionByRevisionIdError {
    Status400(models::ErrorDetail),
    Status404(models::ErrorDetail),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_subject_revisions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSubjectRevisionsError {
    Status400(models::ErrorDetail),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_subjects`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSubjectsError {
    Status400(models::ErrorDetail),
    Status404(models::ErrorDetail),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_user_avatar_by_name`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUserAvatarByNameError {
    Status400(models::ErrorDetail),
    Status404(models::ErrorDetail),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_user_by_name`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUserByNameError {
    Status400(models::ErrorDetail),
    Status404(models::ErrorDetail),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_user_character_collection`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUserCharacterCollectionError {
    Status400(models::ErrorDetail),
    Status404(models::ErrorDetail),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_user_character_collections`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUserCharacterCollectionsError {
    Status404(models::ErrorDetail),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_user_collection`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUserCollectionError {
    Status400(models::ErrorDetail),
    Status404(models::ErrorDetail),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_user_collections_by_username`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUserCollectionsByUsernameError {
    Status400(models::ErrorDetail),
    Status404(models::ErrorDetail),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_user_episode_collection`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUserEpisodeCollectionError {
    Status400(models::ErrorDetail),
    Status401(models::ErrorDetail),
    Status404(models::ErrorDetail),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_user_person_collection`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUserPersonCollectionError {
    Status400(models::ErrorDetail),
    Status404(models::ErrorDetail),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_user_person_collections`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUserPersonCollectionsError {
    Status404(models::ErrorDetail),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_user_subject_episode_collection`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUserSubjectEpisodeCollectionError {
    Status400(models::ErrorDetail),
    Status401(models::ErrorDetail),
    Status404(models::ErrorDetail),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`new_index`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum NewIndexError {
    Status401(models::ErrorDetail),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`patch_user_collection`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PatchUserCollectionError {
    Status400(models::ErrorDetail),
    Status401(models::ErrorDetail),
    Status404(models::ErrorDetail),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`patch_user_subject_episode_collection`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PatchUserSubjectEpisodeCollectionError {
    Status400(models::ErrorDetail),
    Status401(models::ErrorDetail),
    Status404(models::ErrorDetail),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_user_collection`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostUserCollectionError {
    Status400(models::ErrorDetail),
    Status401(models::ErrorDetail),
    Status404(models::ErrorDetail),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`put_user_episode_collection`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PutUserEpisodeCollectionError {
    Status400(models::ErrorDetail),
    Status401(models::ErrorDetail),
    Status404(models::ErrorDetail),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_characters`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchCharactersError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_persons`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchPersonsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_subjects`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchSubjectsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`uncollect_character_by_character_id_and_user_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UncollectCharacterByCharacterIdAndUserIdError {
    Status400(models::ErrorDetail),
    Status401(models::ErrorDetail),
    Status404(models::ErrorDetail),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`uncollect_index_by_index_id_and_user_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UncollectIndexByIndexIdAndUserIdError {
    Status401(models::ErrorDetail),
    Status404(models::ErrorDetail),
    Status500(models::ErrorDetail),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`uncollect_person_by_person_id_and_user_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UncollectPersonByPersonIdAndUserIdError {
    Status400(models::ErrorDetail),
    Status401(models::ErrorDetail),
    Status404(models::ErrorDetail),
    UnknownValue(serde_json::Value),
}

pub async fn add_subject_to_index_by_index_id(
    configuration: &configuration::Configuration,
    index_id: i32,
    index_subject_add_info: Option<models::IndexSubjectAddInfo>,
) -> Result<(), Error<AddSubjectToIndexByIndexIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_index_id = index_id;
    let p_index_subject_add_info = index_subject_add_info;

    let uri_str = format!(
        "{}/v0/indices/{index_id}/subjects",
        configuration.base_path,
        index_id = p_index_id
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_index_subject_add_info);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AddSubjectToIndexByIndexIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// 为当前用户收藏角色
pub async fn collect_character_by_character_id_and_user_id(
    configuration: &configuration::Configuration,
    character_id: i32,
) -> Result<(), Error<CollectCharacterByCharacterIdAndUserIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_character_id = character_id;

    let uri_str = format!(
        "{}/v0/characters/{character_id}/collect",
        configuration.base_path,
        character_id = p_character_id
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CollectCharacterByCharacterIdAndUserIdError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// 为当前用户收藏一条目录
pub async fn collect_index_by_index_id_and_user_id(
    configuration: &configuration::Configuration,
    index_id: i32,
) -> Result<(), Error<CollectIndexByIndexIdAndUserIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_index_id = index_id;

    let uri_str = format!(
        "{}/v0/indices/{index_id}/collect",
        configuration.base_path,
        index_id = p_index_id
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CollectIndexByIndexIdAndUserIdError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// 为当前用户收藏人物
pub async fn collect_person_by_person_id_and_user_id(
    configuration: &configuration::Configuration,
    person_id: i32,
) -> Result<(), Error<CollectPersonByPersonIdAndUserIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_person_id = person_id;

    let uri_str = format!(
        "{}/v0/persons/{person_id}/collect",
        configuration.base_path,
        person_id = p_person_id
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CollectPersonByPersonIdAndUserIdError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn delelte_subject_from_index_by_index_id_and_subject_id(
    configuration: &configuration::Configuration,
    index_id: i32,
    subject_id: i32,
) -> Result<(), Error<DelelteSubjectFromIndexByIndexIdAndSubjectIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_index_id = index_id;
    let p_subject_id = subject_id;

    let uri_str = format!(
        "{}/v0/indices/{index_id}/subjects/{subject_id}",
        configuration.base_path,
        index_id = p_index_id,
        subject_id = p_subject_id
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DelelteSubjectFromIndexByIndexIdAndSubjectIdError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn edit_index_by_id(
    configuration: &configuration::Configuration,
    index_id: i32,
    index_basic_info: Option<models::IndexBasicInfo>,
) -> Result<models::Index, Error<EditIndexByIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_index_id = index_id;
    let p_index_basic_info = index_basic_info;

    let uri_str = format!(
        "{}/v0/indices/{index_id}",
        configuration.base_path,
        index_id = p_index_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_index_basic_info);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Index`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Index`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EditIndexByIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// 如果条目不存在于目录，会创建该条目
pub async fn edit_index_subjects_by_index_id_and_subject_id(
    configuration: &configuration::Configuration,
    index_id: i32,
    subject_id: i32,
    index_subject_edit_info: Option<models::IndexSubjectEditInfo>,
) -> Result<(), Error<EditIndexSubjectsByIndexIdAndSubjectIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_index_id = index_id;
    let p_subject_id = subject_id;
    let p_index_subject_edit_info = index_subject_edit_info;

    let uri_str = format!(
        "{}/v0/indices/{index_id}/subjects/{subject_id}",
        configuration.base_path,
        index_id = p_index_id,
        subject_id = p_subject_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_index_subject_edit_info);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<EditIndexSubjectsByIndexIdAndSubjectIdError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn get_calendar(
    configuration: &configuration::Configuration,
) -> Result<Vec<models::GetCalendar200ResponseInner>, Error<GetCalendarError>> {
    let uri_str = format!("{}/calendar", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GetCalendar200ResponseInner&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GetCalendar200ResponseInner&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetCalendarError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// cache with 60s
pub async fn get_character_by_id(
    configuration: &configuration::Configuration,
    character_id: i32,
) -> Result<models::Character, Error<GetCharacterByIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_character_id = character_id;

    let uri_str = format!(
        "{}/v0/characters/{character_id}",
        configuration.base_path,
        character_id = p_character_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Character`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Character`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetCharacterByIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn get_character_image_by_id(
    configuration: &configuration::Configuration,
    character_id: i32,
    r#type: &str,
) -> Result<(), Error<GetCharacterImageByIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_character_id = character_id;
    let p_type = r#type;

    let uri_str = format!(
        "{}/v0/characters/{character_id}/image",
        configuration.base_path,
        character_id = p_character_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("type", &p_type.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<GetCharacterImageByIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn get_character_revision_by_revision_id(
    configuration: &configuration::Configuration,
    revision_id: i32,
) -> Result<models::CharacterRevision, Error<GetCharacterRevisionByRevisionIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_revision_id = revision_id;

    let uri_str = format!(
        "{}/v0/revisions/characters/{revision_id}",
        configuration.base_path,
        revision_id = p_revision_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CharacterRevision`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CharacterRevision`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetCharacterRevisionByRevisionIdError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn get_character_revisions(
    configuration: &configuration::Configuration,
    character_id: i32,
    limit: Option<i32>,
    offset: Option<i32>,
) -> Result<models::PagedRevision, Error<GetCharacterRevisionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_character_id = character_id;
    let p_limit = limit;
    let p_offset = offset;

    let uri_str = format!("{}/v0/revisions/characters", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("character_id", &p_character_id.to_string())]);
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PagedRevision`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PagedRevision`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetCharacterRevisionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn get_episode_by_id(
    configuration: &configuration::Configuration,
    episode_id: i32,
) -> Result<models::EpisodeDetail, Error<GetEpisodeByIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_episode_id = episode_id;

    let uri_str = format!(
        "{}/v0/episodes/{episode_id}",
        configuration.base_path,
        episode_id = p_episode_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EpisodeDetail`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EpisodeDetail`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetEpisodeByIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn get_episode_revision_by_revision_id(
    configuration: &configuration::Configuration,
    revision_id: i32,
) -> Result<models::DetailedRevision, Error<GetEpisodeRevisionByRevisionIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_revision_id = revision_id;

    let uri_str = format!(
        "{}/v0/revisions/episodes/{revision_id}",
        configuration.base_path,
        revision_id = p_revision_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DetailedRevision`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DetailedRevision`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetEpisodeRevisionByRevisionIdError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn get_episode_revisions(
    configuration: &configuration::Configuration,
    episode_id: i32,
    limit: Option<i32>,
    offset: Option<i32>,
) -> Result<models::PagedRevision, Error<GetEpisodeRevisionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_episode_id = episode_id;
    let p_limit = limit;
    let p_offset = offset;

    let uri_str = format!("{}/v0/revisions/episodes", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("episode_id", &p_episode_id.to_string())]);
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PagedRevision`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PagedRevision`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetEpisodeRevisionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn get_episodes(
    configuration: &configuration::Configuration,
    subject_id: i32,
    r#type: Option<models::EpType>,
    limit: Option<i32>,
    offset: Option<i32>,
) -> Result<models::PagedEpisode, Error<GetEpisodesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_subject_id = subject_id;
    let p_type = r#type;
    let p_limit = limit;
    let p_offset = offset;

    let uri_str = format!("{}/v0/episodes", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("subject_id", &p_subject_id.to_string())]);
    if let Some(ref param_value) = p_type {
        req_builder = req_builder.query(&[("type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PagedEpisode`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PagedEpisode`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetEpisodesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn get_index_by_id(
    configuration: &configuration::Configuration,
    index_id: i32,
) -> Result<models::Index, Error<GetIndexByIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_index_id = index_id;

    let uri_str = format!(
        "{}/v0/indices/{index_id}",
        configuration.base_path,
        index_id = p_index_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Index`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Index`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetIndexByIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn get_index_subjects_by_index_id(
    configuration: &configuration::Configuration,
    index_id: i32,
    r#type: Option<models::SubjectType>,
    limit: Option<i32>,
    offset: Option<i32>,
) -> Result<(), Error<GetIndexSubjectsByIndexIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_index_id = index_id;
    let p_type = r#type;
    let p_limit = limit;
    let p_offset = offset;

    let uri_str = format!(
        "{}/v0/indices/{index_id}/subjects",
        configuration.base_path,
        index_id = p_index_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_type {
        req_builder = req_builder.query(&[("type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<GetIndexSubjectsByIndexIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// 返回当前 Access Token 对应的用户信息
pub async fn get_myself(
    configuration: &configuration::Configuration,
) -> Result<models::GetMyself200Response, Error<GetMyselfError>> {
    let uri_str = format!("{}/v0/me", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetMyself200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetMyself200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMyselfError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// cache with 60s
pub async fn get_person_by_id(
    configuration: &configuration::Configuration,
    person_id: i32,
) -> Result<models::PersonDetail, Error<GetPersonByIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_person_id = person_id;

    let uri_str = format!(
        "{}/v0/persons/{person_id}",
        configuration.base_path,
        person_id = p_person_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PersonDetail`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PersonDetail`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetPersonByIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn get_person_image_by_id(
    configuration: &configuration::Configuration,
    person_id: i32,
    r#type: &str,
) -> Result<(), Error<GetPersonImageByIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_person_id = person_id;
    let p_type = r#type;

    let uri_str = format!(
        "{}/v0/persons/{person_id}/image",
        configuration.base_path,
        person_id = p_person_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("type", &p_type.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<GetPersonImageByIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn get_person_revision_by_revision_id(
    configuration: &configuration::Configuration,
    revision_id: i32,
) -> Result<models::PersonRevision, Error<GetPersonRevisionByRevisionIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_revision_id = revision_id;

    let uri_str = format!(
        "{}/v0/revisions/persons/{revision_id}",
        configuration.base_path,
        revision_id = p_revision_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PersonRevision`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PersonRevision`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetPersonRevisionByRevisionIdError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn get_person_revisions(
    configuration: &configuration::Configuration,
    person_id: i32,
    limit: Option<i32>,
    offset: Option<i32>,
) -> Result<models::PagedRevision, Error<GetPersonRevisionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_person_id = person_id;
    let p_limit = limit;
    let p_offset = offset;

    let uri_str = format!("{}/v0/revisions/persons", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("person_id", &p_person_id.to_string())]);
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PagedRevision`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PagedRevision`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetPersonRevisionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn get_related_characters_by_person_id(
    configuration: &configuration::Configuration,
    person_id: i32,
) -> Result<Vec<models::PersonCharacter>, Error<GetRelatedCharactersByPersonIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_person_id = person_id;

    let uri_str = format!(
        "{}/v0/persons/{person_id}/characters",
        configuration.base_path,
        person_id = p_person_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::PersonCharacter&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::PersonCharacter&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetRelatedCharactersByPersonIdError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn get_related_characters_by_subject_id(
    configuration: &configuration::Configuration,
    subject_id: i32,
) -> Result<Vec<models::RelatedCharacter>, Error<GetRelatedCharactersBySubjectIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_subject_id = subject_id;

    let uri_str = format!(
        "{}/v0/subjects/{subject_id}/characters",
        configuration.base_path,
        subject_id = p_subject_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::RelatedCharacter&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::RelatedCharacter&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetRelatedCharactersBySubjectIdError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn get_related_persons_by_character_id(
    configuration: &configuration::Configuration,
    character_id: i32,
) -> Result<Vec<models::CharacterPerson>, Error<GetRelatedPersonsByCharacterIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_character_id = character_id;

    let uri_str = format!(
        "{}/v0/characters/{character_id}/persons",
        configuration.base_path,
        character_id = p_character_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::CharacterPerson&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::CharacterPerson&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetRelatedPersonsByCharacterIdError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn get_related_persons_by_subject_id(
    configuration: &configuration::Configuration,
    subject_id: i32,
) -> Result<Vec<models::RelatedPerson>, Error<GetRelatedPersonsBySubjectIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_subject_id = subject_id;

    let uri_str = format!(
        "{}/v0/subjects/{subject_id}/persons",
        configuration.base_path,
        subject_id = p_subject_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::RelatedPerson&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::RelatedPerson&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetRelatedPersonsBySubjectIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn get_related_subjects_by_character_id(
    configuration: &configuration::Configuration,
    character_id: i32,
) -> Result<Vec<models::V0RelatedSubject>, Error<GetRelatedSubjectsByCharacterIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_character_id = character_id;

    let uri_str = format!(
        "{}/v0/characters/{character_id}/subjects",
        configuration.base_path,
        character_id = p_character_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::V0RelatedSubject&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::V0RelatedSubject&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetRelatedSubjectsByCharacterIdError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn get_related_subjects_by_person_id(
    configuration: &configuration::Configuration,
    person_id: i32,
) -> Result<Vec<models::V0RelatedSubject>, Error<GetRelatedSubjectsByPersonIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_person_id = person_id;

    let uri_str = format!(
        "{}/v0/persons/{person_id}/subjects",
        configuration.base_path,
        person_id = p_person_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::V0RelatedSubject&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::V0RelatedSubject&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetRelatedSubjectsByPersonIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn get_related_subjects_by_subject_id(
    configuration: &configuration::Configuration,
    subject_id: i32,
) -> Result<Vec<models::V0SubjectRelation>, Error<GetRelatedSubjectsBySubjectIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_subject_id = subject_id;

    let uri_str = format!(
        "{}/v0/subjects/{subject_id}/subjects",
        configuration.base_path,
        subject_id = p_subject_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::V0SubjectRelation&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::V0SubjectRelation&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetRelatedSubjectsBySubjectIdError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// cache with 300s
pub async fn get_subject_by_id(
    configuration: &configuration::Configuration,
    subject_id: i32,
) -> Result<models::Subject, Error<GetSubjectByIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_subject_id = subject_id;

    let uri_str = format!(
        "{}/v0/subjects/{subject_id}",
        configuration.base_path,
        subject_id = p_subject_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Subject`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Subject`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSubjectByIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn get_subject_image_by_id(
    configuration: &configuration::Configuration,
    subject_id: i32,
    r#type: &str,
) -> Result<(), Error<GetSubjectImageByIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_subject_id = subject_id;
    let p_type = r#type;

    let uri_str = format!(
        "{}/v0/subjects/{subject_id}/image",
        configuration.base_path,
        subject_id = p_subject_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("type", &p_type.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSubjectImageByIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn get_subject_revision_by_revision_id(
    configuration: &configuration::Configuration,
    revision_id: i32,
) -> Result<models::SubjectRevision, Error<GetSubjectRevisionByRevisionIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_revision_id = revision_id;

    let uri_str = format!(
        "{}/v0/revisions/subjects/{revision_id}",
        configuration.base_path,
        revision_id = p_revision_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SubjectRevision`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SubjectRevision`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSubjectRevisionByRevisionIdError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn get_subject_revisions(
    configuration: &configuration::Configuration,
    subject_id: i32,
    limit: Option<i32>,
    offset: Option<i32>,
) -> Result<models::PagedRevision, Error<GetSubjectRevisionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_subject_id = subject_id;
    let p_limit = limit;
    let p_offset = offset;

    let uri_str = format!("{}/v0/revisions/subjects", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("subject_id", &p_subject_id.to_string())]);
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PagedRevision`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PagedRevision`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSubjectRevisionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// 第一页会 cache 24h，之后会 cache 1h
pub async fn get_subjects(
    configuration: &configuration::Configuration,
    r#type: models::SubjectType,
    cat: Option<models::SubjectCategory>,
    series: Option<bool>,
    platform: Option<&str>,
    sort: Option<&str>,
    year: Option<i32>,
    month: Option<i32>,
    limit: Option<i32>,
    offset: Option<i32>,
) -> Result<models::PagedSubject, Error<GetSubjectsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_type = r#type;
    let p_cat = cat;
    let p_series = series;
    let p_platform = platform;
    let p_sort = sort;
    let p_year = year;
    let p_month = month;
    let p_limit = limit;
    let p_offset = offset;

    let uri_str = format!("{}/v0/subjects", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("type", &p_type.to_string())]);
    if let Some(ref param_value) = p_cat {
        req_builder = req_builder.query(&[("cat", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_series {
        req_builder = req_builder.query(&[("series", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_platform {
        req_builder = req_builder.query(&[("platform", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort {
        req_builder = req_builder.query(&[("sort", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_year {
        req_builder = req_builder.query(&[("year", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_month {
        req_builder = req_builder.query(&[("month", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PagedSubject`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PagedSubject`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSubjectsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// 获取用户头像，302 重定向至头像地址，设置了 username 之后无法使用 UID 查询。
pub async fn get_user_avatar_by_name(
    configuration: &configuration::Configuration,
    username: &str,
    r#type: &str,
) -> Result<(), Error<GetUserAvatarByNameError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_username = username;
    let p_type = r#type;

    let uri_str = format!(
        "{}/v0/users/{username}/avatar",
        configuration.base_path,
        username = crate::apis::urlencode(p_username)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("type", &p_type.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<GetUserAvatarByNameError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// 获取用户信息
pub async fn get_user_by_name(
    configuration: &configuration::Configuration,
    username: &str,
) -> Result<models::User, Error<GetUserByNameError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_username = username;

    let uri_str = format!(
        "{}/v0/users/{username}",
        configuration.base_path,
        username = crate::apis::urlencode(p_username)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::User`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::User`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetUserByNameError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn get_user_character_collection(
    configuration: &configuration::Configuration,
    username: &str,
    character_id: i32,
) -> Result<models::UserCharacterCollection, Error<GetUserCharacterCollectionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_username = username;
    let p_character_id = character_id;

    let uri_str = format!(
        "{}/v0/users/{username}/collections/-/characters/{character_id}",
        configuration.base_path,
        username = crate::apis::urlencode(p_username),
        character_id = p_character_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserCharacterCollection`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserCharacterCollection`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetUserCharacterCollectionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn get_user_character_collections(
    configuration: &configuration::Configuration,
    username: &str,
) -> Result<models::PagedUserCharacterCollection, Error<GetUserCharacterCollectionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_username = username;

    let uri_str = format!(
        "{}/v0/users/{username}/collections/-/characters",
        configuration.base_path,
        username = crate::apis::urlencode(p_username)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PagedUserCharacterCollection`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PagedUserCharacterCollection`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetUserCharacterCollectionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// 获取对应用户的收藏，查看私有收藏需要 access token
pub async fn get_user_collection(
    configuration: &configuration::Configuration,
    username: &str,
    subject_id: i32,
) -> Result<models::UserSubjectCollection, Error<GetUserCollectionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_username = username;
    let p_subject_id = subject_id;

    let uri_str = format!(
        "{}/v0/users/{username}/collections/{subject_id}",
        configuration.base_path,
        username = crate::apis::urlencode(p_username),
        subject_id = p_subject_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserSubjectCollection`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserSubjectCollection`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetUserCollectionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// 获取对应用户的收藏，查看私有收藏需要access token。
pub async fn get_user_collections_by_username(
    configuration: &configuration::Configuration,
    username: &str,
    subject_type: Option<models::SubjectType>,
    r#type: Option<&str>,
    limit: Option<i32>,
    offset: Option<i32>,
) -> Result<models::PagedUserCollection, Error<GetUserCollectionsByUsernameError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_username = username;
    let p_subject_type = subject_type;
    let p_type = r#type;
    let p_limit = limit;
    let p_offset = offset;

    let uri_str = format!(
        "{}/v0/users/{username}/collections",
        configuration.base_path,
        username = crate::apis::urlencode(p_username)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_subject_type {
        req_builder = req_builder.query(&[("subject_type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_type {
        req_builder = req_builder.query(&[("type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PagedUserCollection`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PagedUserCollection`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetUserCollectionsByUsernameError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn get_user_episode_collection(
    configuration: &configuration::Configuration,
    episode_id: i32,
) -> Result<models::UserEpisodeCollection, Error<GetUserEpisodeCollectionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_episode_id = episode_id;

    let uri_str = format!(
        "{}/v0/users/-/collections/-/episodes/{episode_id}",
        configuration.base_path,
        episode_id = p_episode_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserEpisodeCollection`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserEpisodeCollection`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetUserEpisodeCollectionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn get_user_person_collection(
    configuration: &configuration::Configuration,
    username: &str,
    person_id: i32,
) -> Result<models::UserPersonCollection, Error<GetUserPersonCollectionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_username = username;
    let p_person_id = person_id;

    let uri_str = format!(
        "{}/v0/users/{username}/collections/-/persons/{person_id}",
        configuration.base_path,
        username = crate::apis::urlencode(p_username),
        person_id = p_person_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserPersonCollection`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserPersonCollection`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetUserPersonCollectionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn get_user_person_collections(
    configuration: &configuration::Configuration,
    username: &str,
) -> Result<models::PagedUserPersonCollection, Error<GetUserPersonCollectionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_username = username;

    let uri_str = format!(
        "{}/v0/users/{username}/collections/-/persons",
        configuration.base_path,
        username = crate::apis::urlencode(p_username)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PagedUserPersonCollection`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PagedUserPersonCollection`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetUserPersonCollectionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn get_user_subject_episode_collection(
    configuration: &configuration::Configuration,
    subject_id: i32,
    offset: Option<i32>,
    limit: Option<i32>,
    episode_type: Option<models::EpType>,
) -> Result<
    models::GetUserSubjectEpisodeCollection200Response,
    Error<GetUserSubjectEpisodeCollectionError>,
> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_subject_id = subject_id;
    let p_offset = offset;
    let p_limit = limit;
    let p_episode_type = episode_type;

    let uri_str = format!(
        "{}/v0/users/-/collections/{subject_id}/episodes",
        configuration.base_path,
        subject_id = p_subject_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_episode_type {
        req_builder = req_builder.query(&[("episode_type", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetUserSubjectEpisodeCollection200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetUserSubjectEpisodeCollection200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetUserSubjectEpisodeCollectionError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn new_index(
    configuration: &configuration::Configuration,
) -> Result<models::Index, Error<NewIndexError>> {
    let uri_str = format!("{}/v0/indices", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Index`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Index`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<NewIndexError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// 修改条目收藏状态  由于直接修改剧集条目的完成度可能会引起意料之外效果，只能用于修改书籍类条目的完成度。  PATCH 方法的所有请求体字段均可选
pub async fn patch_user_collection(
    configuration: &configuration::Configuration,
    subject_id: i32,
    user_subject_collection_modify_payload: Option<models::UserSubjectCollectionModifyPayload>,
) -> Result<(), Error<PatchUserCollectionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_subject_id = subject_id;
    let p_user_subject_collection_modify_payload = user_subject_collection_modify_payload;

    let uri_str = format!(
        "{}/v0/users/-/collections/{subject_id}",
        configuration.base_path,
        subject_id = p_subject_id
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_user_subject_collection_modify_payload);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<PatchUserCollectionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// 同时会重新计算条目的完成度
pub async fn patch_user_subject_episode_collection(
    configuration: &configuration::Configuration,
    subject_id: i32,
    patch_user_subject_episode_collection_request: Option<
        models::PatchUserSubjectEpisodeCollectionRequest,
    >,
) -> Result<(), Error<PatchUserSubjectEpisodeCollectionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_subject_id = subject_id;
    let p_patch_user_subject_episode_collection_request =
        patch_user_subject_episode_collection_request;

    let uri_str = format!(
        "{}/v0/users/-/collections/{subject_id}/episodes",
        configuration.base_path,
        subject_id = p_subject_id
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_patch_user_subject_episode_collection_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<PatchUserSubjectEpisodeCollectionError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// 修改条目收藏状态, 如果不存在则创建，如果存在则修改  由于直接修改剧集条目的完成度可能会引起意料之外效果，只能用于修改书籍类条目的完成度。  方法的所有请求体字段均可选
pub async fn post_user_collection(
    configuration: &configuration::Configuration,
    subject_id: i32,
    user_subject_collection_modify_payload: Option<models::UserSubjectCollectionModifyPayload>,
) -> Result<(), Error<PostUserCollectionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_subject_id = subject_id;
    let p_user_subject_collection_modify_payload = user_subject_collection_modify_payload;

    let uri_str = format!(
        "{}/v0/users/-/collections/{subject_id}",
        configuration.base_path,
        subject_id = p_subject_id
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_user_subject_collection_modify_payload);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<PostUserCollectionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn put_user_episode_collection(
    configuration: &configuration::Configuration,
    episode_id: i32,
    put_user_episode_collection_request: Option<models::PutUserEpisodeCollectionRequest>,
) -> Result<(), Error<PutUserEpisodeCollectionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_episode_id = episode_id;
    let p_put_user_episode_collection_request = put_user_episode_collection_request;

    let uri_str = format!(
        "{}/v0/users/-/collections/-/episodes/{episode_id}",
        configuration.base_path,
        episode_id = p_episode_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_put_user_episode_collection_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<PutUserEpisodeCollectionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// ## 实验性 API， 本 schema 和实际的 API 行为都可能随时发生改动  目前支持的筛选条件包括: - `nsfw`: 使用 `include` 包含NSFW搜索结果。默认排除搜索NSFW条目。无权限情况下忽略此选项，不会返回NSFW条目。
pub async fn search_characters(
    configuration: &configuration::Configuration,
    limit: Option<i32>,
    offset: Option<i32>,
    search_characters_request: Option<models::SearchCharactersRequest>,
) -> Result<models::PagedCharacter, Error<SearchCharactersError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_limit = limit;
    let p_offset = offset;
    let p_search_characters_request = search_characters_request;

    let uri_str = format!("{}/v0/search/characters", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_search_characters_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PagedCharacter`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PagedCharacter`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchCharactersError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// ## 实验性 API， 本 schema 和实际的 API 行为都可能随时发生改动  目前支持的筛选条件包括: - `career`: 职业，可以多次出现。`且` 关系。  不同筛选条件之间为 `且`
pub async fn search_persons(
    configuration: &configuration::Configuration,
    limit: Option<i32>,
    offset: Option<i32>,
    search_persons_request: Option<models::SearchPersonsRequest>,
) -> Result<models::PagedPerson, Error<SearchPersonsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_limit = limit;
    let p_offset = offset;
    let p_search_persons_request = search_persons_request;

    let uri_str = format!("{}/v0/search/persons", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_search_persons_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PagedPerson`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PagedPerson`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchPersonsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// ## 实验性 API， 本 schema 和实际的 API 行为都可能随时发生改动  目前支持的筛选条件包括: - `type`: 条目类型，参照 `SubjectType` enum， `或`。 - `tag`: 标签，可以多次出现。`且` 关系。 - `air_date`: 播出日期/发售日期。`且` 关系。 - `rating`: 用于搜索指定评分的条目。`且` 关系。 - `rank`: 用于搜索指定排名的条目。`且` 关系。 - `nsfw`: 使用 `include` 包含NSFW搜索结果。默认排除搜索NSFW条目。无权限情况下忽略此选项，不会返回NSFW条目。  不同筛选条件之间为 `且`
pub async fn search_subjects(
    configuration: &configuration::Configuration,
    limit: Option<i32>,
    offset: Option<i32>,
    search_subjects_request: Option<models::SearchSubjectsRequest>,
) -> Result<models::PagedSubject, Error<SearchSubjectsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_limit = limit;
    let p_offset = offset;
    let p_search_subjects_request = search_subjects_request;

    let uri_str = format!("{}/v0/search/subjects", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_search_subjects_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PagedSubject`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PagedSubject`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchSubjectsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// 为当前用户取消收藏角色
pub async fn uncollect_character_by_character_id_and_user_id(
    configuration: &configuration::Configuration,
    character_id: i32,
) -> Result<(), Error<UncollectCharacterByCharacterIdAndUserIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_character_id = character_id;

    let uri_str = format!(
        "{}/v0/characters/{character_id}/collect",
        configuration.base_path,
        character_id = p_character_id
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<UncollectCharacterByCharacterIdAndUserIdError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// 为当前用户取消收藏一条目录
pub async fn uncollect_index_by_index_id_and_user_id(
    configuration: &configuration::Configuration,
    index_id: i32,
) -> Result<(), Error<UncollectIndexByIndexIdAndUserIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_index_id = index_id;

    let uri_str = format!(
        "{}/v0/indices/{index_id}/collect",
        configuration.base_path,
        index_id = p_index_id
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<UncollectIndexByIndexIdAndUserIdError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// 为当前用户取消收藏人物
pub async fn uncollect_person_by_person_id_and_user_id(
    configuration: &configuration::Configuration,
    person_id: i32,
) -> Result<(), Error<UncollectPersonByPersonIdAndUserIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_person_id = person_id;

    let uri_str = format!(
        "{}/v0/persons/{person_id}/collect",
        configuration.base_path,
        person_id = p_person_id
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<UncollectPersonByPersonIdAndUserIdError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
